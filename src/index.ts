import Cloudflare from "cloudflare";
import "dotenv/config";
import { exit, stdin, stdout } from "node:process";
import { createInterface } from "node:readline/promises";
const packageJson = require("../package.json");

const cloudflare = new Cloudflare({
  apiToken: process.env.CLOUDFLARE_API_TOKEN,
});

// TODO: Choose domain from the list of zones via prompt
// TODO: Verify the zone exists, confirm with user that the zone is correct.
const targetZone = process.env.TARGET_ZONE_ID!;
const commentTag = `${packageJson.name} v${packageJson.version}`;

type Context = {
  targetZone: string;
  domain: string;
};

async function confirmAction(message: string): Promise<void> {
  const readline = createInterface({ input: stdin, output: stdout });
  const answer = await readline.question(`${message} (y/n) `);
  readline.close();
  if (answer.toLowerCase() !== "y") exit(0);
}

async function list(
  params: Cloudflare.DNS.RecordListParams,
  options?: Cloudflare.RequestOptions,
): Promise<Cloudflare.DNS.Record[]> {
  const records: Cloudflare.DNS.Record[] = [];
  const response = await cloudflare.dns.records.list(params, options);
  for await (const page of response.iterPages())
    records.push(...page.getPaginatedItems());
  return records;
}

async function handleMxRecords(ctx: Context) {
  // Get all existing MX records
  const existingRecords = await list({
    zone_id: targetZone,
    type: "MX",
    per_page: 50,
  });

  // Implied: name = @
  const mxRecords: [string, number, boolean][] = [
    ["in1-smtp.messagingengine.com", 10, false],
    ["in2-smtp.messagingengine.com", 20, false],
  ];

  // Update or delete existing records
  for await (const record of existingRecords) {
    // if the record's content doesn't match any of the required records, delete it
    const matchIndex: number = mxRecords.findIndex(
      ([content, _]) => record.name == ctx.domain && content === record.content,
    );

    // Delete the record if it doesn't match any of the required records
    if (matchIndex === -1) {
      console.log(`[DELETE] MX ${record.name} -> ${record.content}`);
      await cloudflare.dns.records.delete(record.id!, {
        zone_id: targetZone,
      });

      // Skip to the next record, nothing to be updated
      continue;
    } else {
      // Mark the required record as existing, so we don't create it later
      mxRecords[matchIndex][2] = true;
    }

    // Check if the record's priority matches the required priority
    const requiredPriority = mxRecords[matchIndex][1];
    if ((record as Cloudflare.DNS.MXRecord).priority !== requiredPriority) {
      console.log(`[UPDATE] MX ${record.name} -> ${record.content}`);
      await cloudflare.dns.records.update(record.id!, {
        zone_id: targetZone,
        name: record.name,
        type: "MX",
        content: record.content as string,
        priority: requiredPriority,
        comment:
          record.comment != undefined
            ? `${record.comment}, Updated by ${commentTag}`
            : `Updated by ${commentTag}`,
      });
    }
  }

  // Create new records
  for (const [content, priority, exists] of mxRecords) {
    if (exists) continue;
    console.log(`[CREATE] MX ${ctx.domain} -> ${content}`);
    await cloudflare.dns.records.create({
      zone_id: targetZone,
      name: "@",
      type: "MX",
      content: content,
      priority: priority,
      comment: `Generated by ${commentTag}`,
    });
  }

  console.log("MX records updated successfully.");
}

async function handleCnameRecords(ctx: Context) {
  const requiredRecords = [
    ["fm1._domainkey", `fm1.${ctx.domain}.dkim.fmhosted.com`],
    ["fm2._domainkey", `fm2.${ctx.domain}.dkim.fmhosted.com`],
    ["fm3._domainkey", `fm3.${ctx.domain}.dkim.fmhosted.com`],
  ];

  // Get all existing CNAME records
  const existingRecords = await list({
    zone_id: targetZone,
    type: "CNAME",
    per_page: 50,
  });

  // Iterate all required records, update or create them
  for (const [requiredName, requiredContent] of requiredRecords) {
    const recordExists = existingRecords.find(
      (record) => record.name === requiredName + "." + ctx.domain,
    );

    // Update existing record
    if (recordExists) {
      // Skip if the record's content is already correct
      if (recordExists.content === requiredContent) continue;

      console.log(`[UPDATE] CNAME ${requiredName} -> ${requiredContent}`);
      await cloudflare.dns.records.update(recordExists.id!, {
        zone_id: targetZone,
        name: recordExists.name,
        type: "CNAME",
        content: requiredContent,
        comment:
          recordExists.comment != undefined
            ? `${recordExists.comment}, Updated by ${commentTag}`
            : `Updated by ${commentTag}`,
      });
    }

    // Create new record
    console.log(`[CREATE] CNAME ${requiredName} -> ${requiredContent}`);
    await cloudflare.dns.records.create({
      zone_id: targetZone,
      name: requiredName,
      type: "CNAME",
      content: requiredContent,
      comment: `Generated by ${commentTag}`,
    });
  }

  console.log("CNAME/DKIM records updated successfully.");
}

async function handleSpfRecords() {
  const spfRecord = "v=spf1 include:spf.messagingengine.com ?all";

  // Get all existing SPF records
  const existingRecords = await list({
    zone_id: targetZone,
    type: "TXT",
    per_page: 50,
  });
  let recordAlreadyExists = false;

  // Check if the SPF record already exists
  for await (const record of existingRecords) {
    if (record.content === spfRecord) {
      recordAlreadyExists = true;
      break;
    }
  }

  // If record was not found, delete all existing SPF records
  if (!recordAlreadyExists) {
    for await (const record of existingRecords) {
      if ((record.content as string).startsWith("v=spf1")) {
        console.log(`[DELETE] SPF @ -> ${record.content}`);

        // Confirm with user
        await confirmAction(
          `SPF record found: ${record.content}. Do you want to delete it?`,
        );

        // Delete the record
        await cloudflare.dns.records.delete(record.id!, {
          zone_id: targetZone,
        });
      }
    }
  }

  // Add new SPF record
  if (!recordAlreadyExists) {
    console.log(`[CREATE] SPF @ -> ${spfRecord}`);
    await cloudflare.dns.records.create({
      zone_id: targetZone,
      type: "TXT",
      name: "@",
      content: spfRecord,
    });
  }

  console.log("SPF records updated successfully.");
}

async function main() {
  // TODO: Environment variable validation, type checking
  // TODO: Proper stdout/stderr logging, format, color
  // TODO: Pre-run permission checks
  // TODO: -y --confirm-all flag
  // TODO: DMARC record (add, remove, delete, change) + doclink prompt, --dmarc flag

  // If target zone is not provided, list all zones with name + id
  if (!targetZone) {
    const response = await cloudflare.zones.list({ per_page: 2 });
    for await (const page of response.iterPages()) {
      page.getPaginatedItems().forEach((zone) => {
        console.log(`Zone: ${zone.name} (${zone.id})`);
      });
    }
    console.log("Please provide a target zone id via TARGET_ZONE_ID");
    process.exit(1);
  }

  // Get zone details
  const zone = await cloudflare.zones.get({ zone_id: targetZone });
  const ctx = { targetZone, domain: zone.name };

  // Clears MX records, then adds required ones
  await handleMxRecords(ctx);

  // Replace or Add CNAME records
  await handleCnameRecords(ctx);

  // Replace or Add SPF records
  await handleSpfRecords();

  console.log("Done.");
}

main();
